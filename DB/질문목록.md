<br>
💡 데이터베이스의 인덱스에 대해서 설명해주세요.

<br>


추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

---
<br>
💡 인덱스 테이블을 해시 테이블과 B+트리로 구성할때 각각이 어떤 차이점이 있을까요?

<br>

해시 테이블의 경우 해시를 사용하기 때문에 = 비교만 가능하지만 B+트리는 링크드리스트로 연결되어 있어서 부등호 비교가 가능하다.



---
<br>
💡 클러스터형 인덱스에 대해서 설명해주세요.

<br>

정렬된 인덱스로 비 클러스터형 인덱스보다 검색 속도가 더 빠르다.

---
<br>
💡 인덱스를 활용한 검색은 그렇지 않은 검색보다 무조건 빠를까요?

<br>

인덱스가 가득차게 되면 속도 저하가 있을 수 있기 때문에 그렇지 않다.

---
<br>

## 정리

### Index

- Index는 추가적인 공간을 활용하여 데이터와 데이터가 저장된 위치를 저장해 테이블의 검색 속도를 향상
- Index 관리를 위해 Index에 저장된 키에 관한 데이터 추가 시 Index 추가, 데이터 수정 시 해당 데이터의 Index를 사용하지 않음 처리하고 갱신된 데이터에 대한 Index 추가, 데이터 삭제 시 해당 데이터의 Index를 사용하지 않음 처리
    - 추가 연산에 따른 오버헤드 발생
- Index의 장단점
    - 장점
        - 조회 속도 향상
    - 단점
        - Index관리를 위해 DB에 추가적인 저장공간 필요
        - Index관리를 위해 추가 작업 필요
        - Update, Delete, Insert가 빈번한 컬럼에 대해 Index를 걸면 인덱스의 크기가 커져 성능 저하
            - Update, Delete는 실제로 Index를 삭제하는 것이 아니라 사용하지 않음 처리하기 때문
- Index를 사용하면 좋은 경우
    - 규모가 큰 테이블
    - Insert, Update, Delete가 자주 발생하지 않는 컬럼
    - Join, Where, Order by 에 자주 사용되는 컬럼
    - 데이터 중복도가 낮은 컬럼
- Index의 자료구조
    - 해시 테이블
        - 데이터, 데이터의 위치를 key, value로 사용하여 인덱스를 구현
        - 시간복잡도가 O(1)로 빠름
        - = 연산에만 사용할 수 있음
            - Hash 연산으로 value가 결정되다 보니 부등호를 사용할 수 없음
    - B+Tree
        - 자식 노드가 2개 이상인 B-Tree를 개선
        - 리프 노드만 인덱스와함께 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만을 갖음
        - 리프 노드들은 Linked List로 연결되어 있음