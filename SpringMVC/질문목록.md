<br>
💡 WAS(Web Application Server)와 WS(Web Server)의 차이를 설명해주세요.

---
<br>
💡 Spring Framework에 대해 설명해주세요.

---
<br>
💡 @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.

Client에서 받은 요청을 객체로 바인딩하기 위해 사용하는 방법들

- @RequestBody : client가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter(MappingJackson2HttpMessageConverter)를 통해 Java Object로 변환시켜주는 역할
- @RequestParam : 1개의 HTTP 요청 파라미터를 받기 위해 사용 = 1:1로 매칭하여 하나의 값만을 전달해줌 -> query parameter를 controller의 method 인자로 바인딩함
- @ModelAttribute : client가 전송하는 form 형태의 HTTP Body와 요청 파라미터들을 바인딩하기 위해 사용

<br/>

- 참고) @RequestBody와 @ModelAttribute의 차이
  - @ModelAttribute는 바인딩하는 값들을 주입해주는 생성자나 Setter가 없다면 매핑 되지 않음
  - @RequestBody는 요청받은 데이터를 변환시키는 것(Reflection을 사용해 할당)이기 때문에, 생성자나 Setter 함수가 없어도 값이 매핑됨

---
<br>
💡 Spring Boot와 Spring Framework의 차이점을 설명해주세요.

|             | Spring Framework                            | Spring Boot Framework                                                                     | ex)                                                                                                                                                                                     |
|-------------|---------------------------------------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| dependency  | 설정이 길고, 모든 dependency에 대한 버전 관리를 하나하나 해주어야 함 | Spring Framework보다 설정 쉬움, 버전 관리도 자동으로 해줌                                                  | starter를 통한 dependency 자동화 : Spring Framework의 경우 test framework를 사용할 때, Spring Test, JUnit, Hamcrest, Mockito 등 모든 라이브러리를 추가해주어야 하지만, Spring Boot에서는 spring-boot-starter-test만 추가해주면 됨 |
| configuration | 설정이 길고, 모든 어노테이션 및 빈 등록 등을 설정해주어야 함         | AutoConfiguration 기능, <br/> application.properties or application.yml 파일에 설정하면 되어 간단하고 편함 | Spring Boot의 AutoConfiguration(@SpringBootApplication) 기능이 사전에 정의한 라이브러리들을 Bean에 등록해주고 의존성을 주입해줌                                                                                        |
| 배포          | WAS를 정하고 설정하고, war파일을 WAS에 담는 과정 필요         | 내장 WAS(Tomcat or Jetty)를 가지고 있어 jar 파일로 간편하게 배포 가능                                        |                                                                                                                                                                                         |

<br/>

=> 정리 : Spring Framework는 기존 EJB를 대신해 Java application을 더 쉽게 만들 수 있게 해 주고,    
Spring Boot Framework는 Spring framework 위에 구축된 framework로써     
설정의 많은 부분을 자동화화하여 개발, 테스트, 배포가 편해져 Spring Framework보다 개발자가 더욱 개발에만 집중할 수 있도록 도와주는 framework

---
<br>
💡 Spring MVC에 대해 설명해주세요.

- Spring 에서 제공하는 웹 모듈
  - MVC 패턴을 따르면서 Spring만의 독자적인 Class를 통해 처리함
    - MVC 패턴 : Model, View, Controller를 분리한 디자인 패턴
    - Model, View, Controller 모두를 인터페이스를 사용해 규격화해놓아 유연하고 확장성 있게 web application을 설계할 수 있음
- 사용자의 다양한 HTTP request를 처리하고 단순한 텍스트 형식의 응답, rest 형식의 응답, view를 표시하는 html을 반환하는 응답 등이 가능하도록 하는 프레임워크
- 역할을 나누어 처리하기 때문에 서로의 결합도가 낮아져 유지보수가 편해짐
- 구성요소 : DispatcherServlet, HandlerMapping, Model, ViewResolver, View, Controller 등

---
<br>
💡 MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.

`@Controller` 기준으로

- 1) 클라이언트의 모든 요청을 DispatcherServlet이 받음 => 웹 요청(HttpServletRequest)
- 2) DispatcherServlet(Front Controller)은 요청 URL을 HandlerMapping에게 전달하고, 현재 요청에 알맞는 Handler(Controller)와 method에 대한 정보를 알아냄
- 3) Dispatcher Servlet은 Handler를 실행할 수 있는 HandlerAdapter 탐색해서 HandlerAdapter에게 요청 처리를 위임
- 4) HandlerAdapter를 사용해서 Handler의 메소드 실행
- 5) Handler는 비즈니스 로직을 처리하고 결과를 반환함
  - 반환값은 Model과 View
- 6) DispatcherServlet은 view 이름을 ViewResolver에게 전달하여 View 객체를 얻음
- 7) DispatcherServlet은 View에게 Model을 전달하고 화면 표시를 요청
  - Model이 null이면 View를 그대로 사용 / 값이 있으면 View에 Model 데이터를 렌더링함
- 8) DispatcherServlet은 결과(HttpServletResponse)를 클라이언트에게 반환

(`@RestController`의 경우 6, 7 생략   
= ViewResolver를 타지 않고 반환값에 알맞은 MessageConverter를 찾아 응답 본문 작성)

[reference](https://terasolunaorg.github.io/guideline/5.0.1.RELEASE/en/Overview/SpringMVCOverview.html#overview-of-spring-mvc-processing-sequence)

<br/>

- 참고) HandlerMapping에서 요청에 맞는 Handler를 찾았으면 바로 Handler를 호출하면 되지 않나?!   
  - 다양한 Handler -> return 타입 다양(String, ModelAndView 등) -> 다양한 Handler 구현 방식에 맞추어 개발 하는 것은 쉽지 않음

    => 중간에 Adapter를 두는 adapter pattern 사용

    => HandlerAdapter를 사용하면, Handler에서 어떻게 반환하든 이를 처리해 DispatcherServlet에게 ModelAndView 객체로 통일하여 응답을 전달해 줄 수 있음

    => 개발자는 좀 더 비즈니스 로직 구현에 집중할 수 있음

---
<br>
💡 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.

---
<br>
💡 스프링에서 빈(Bean)을 등록하는 방법에 대해 말해보세요.

---
<br>
💡 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
 - 필드 주입, 생성자 주입, setter 주입 에 관하여도 

---
<br>
💡 스프링 빈의 라이프사이클은 어떻게 관리되는지 설명해주세요.

---
<br>
💡 Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요.

---
<br>
💡 관점지향 프로그래밍(AOP, Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요?

---
<br>
💡 Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?

---
<br>
💡 서블릿(Servlet)에 대해 설명해주세요.

---
<br>
💡 서블릿의 동작 방식에 대해 설명해주세요

---
<br>
💡 VO와 BO, DAO, DTO에 대해 설명해주세요.

---
<br>
💡 Spring의 싱글톤 패턴에 대해 설명해주세요.

---
<br>
💡 Spring의 스코프 프로토 타입 빈에 대해 설명해주세요.

---
<br>
💡 Spring Bean에 대해 설명해주세요.

---
<br>
💡 DTO를 사용하는 이유를 설명해주세요.

---
<br>
💡 생성자 injection을 사용하는 이유를 설명해주세요.

---
<br>
💡 servlet dispacher 에 대해 설명해주세요.

---
<br>
💡 객체지향 관점에서 스프링 프레임워크를 바라봤을 때 장단점을 설명해주세요.

