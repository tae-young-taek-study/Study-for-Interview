<br>
💡 @Transactional의 동작 원리에 대해 설명해주세요.

- 비즈니스 로직과 트랜잭션 코드가 공존하면 코드 중복이 발생하고 비즈니스 로직에 집중할 수 없는 문제 발생
    - @Transactional 어노테이션을 사용하면 내부적으로 AOP를 통해 트랜잭션 처리코드가 전, 후로 수행됨
        - JDK Dynamic Proxy 혹은 CGLib 방식을 사용해서 트랜잭션 코드를 붙임
        - AspectJ를 사용해 직접 바이트코드를 수정할 수도 있음

---
<br>
💡 @Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명해주세요.

A 메소드는 B 메소드에서 호출하기 때문에 프록시 객체 내부에서 호출되어 @Transactional이 적용되지 않습니다.  

Spring AOP는 2.4버전 이후 CGLIB 방식을 사용하는데 이 때 생성된 프록시 객체가 메서드를 호출할 때 Transaction이 걸리게 됩니다. 그런데 A 메소드는 프록시 객체에서 호출하는 것이 아니라 내부적으로 호출되는 메소드이기 때문에 Transaction이 걸리지 않습니다.  

이 때, 이를 self-invocation 문제라고 하는데 이를 해결하기 위해서는 AOP Context를 사용해 현재 수행하고 있는 프록시에서 해당 메서드를 호출하도록 하는 방법이 있습니다.

---
<br>
💡 A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요.

---
<br>
💡 @Transactional에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요.

---
<br>
💡 JPA N + 1 문제와 발생하는 이유 그리고 해결하는 방법을 설명해주세요.

---
<br>
💡 JPA와 같은 ORM을 사용하면서 쿼리가 복잡해지는 경우에는 어떻게 해결하는게 좋을까요?

---
<br>
💡 Entity에 대해 설명해주세요.

---
<br>
💡 JPA에서 Entity를 설계할때 주의점을 말해주세요.

---
<br>
💡 ORM에 대해 설명해주세요.

---
<br>
💡 JPA 장점, 단점에 대해 설명해주세요.

---
<br>
💡 영속성 컨텍스트에 대해 설명해주세요.

---
<br>
💡 영속성 컨텍스트의 장점에 대해 설명해주세요.

---
<br>
