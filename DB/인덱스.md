<br>
💡 데이터베이스의 인덱스에 대해서 설명해주세요.

<br>


추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

---
<br>
💡 인덱스 테이블을 해시 테이블과 B+트리로 구성할때 각각이 어떤 차이점이 있을까요?

<br>

해시 테이블의 경우 해시를 사용하기 때문에 = 비교만 가능하지만 B+트리는 링크드리스트로 연결되어 있어서 부등호 비교가 가능하다.



---
<br>
💡 클러스터형 인덱스에 대해서 설명해주세요.

<br>

정렬된 인덱스로 비 클러스터형 인덱스보다 검색 속도가 더 빠르다.

---
<br>
💡 인덱스를 활용한 검색은 그렇지 않은 검색보다 무조건 빠를까요?

<br>

인덱스가 가득차게 되면 속도 저하가 있을 수 있기 때문에 그렇지 않다.

---
<br>


💡 In 쿼리의 동작 방식은?

> In 쿼리는 인덱스를 탈까요?

---
<br>
💡 Like 문은 인덱스를 탈까요?

---
<br>
💡 멀티 인덱스란 무엇인가요?

---
<br>

## 정리

### Index

- Index는 추가적인 공간을 활용하여 데이터와 데이터가 저장된 위치를 저장해 테이블의 검색 속도를 향상
- Index 관리를 위해 Index에 저장된 키에 관한 데이터 추가 시 Index 추가, 데이터 수정 시 해당 데이터의 Index를 사용하지 않음 처리하고 갱신된 데이터에 대한 Index 추가, 데이터 삭제 시 해당 데이터의 Index를 사용하지 않음 처리
    - 추가 연산에 따른 오버헤드 발생
- Index의 장단점
    - 장점
        - 조회 속도 향상
    - 단점
        - Index관리를 위해 DB에 추가적인 저장공간 필요
        - Index관리를 위해 추가 작업 필요
        - Update, Delete, Insert가 빈번한 컬럼에 대해 Index를 걸면 인덱스의 크기가 커져 성능 저하
            - Update, Delete는 실제로 Index를 삭제하는 것이 아니라 사용하지 않음 처리하기 때문
- Index를 사용하면 좋은 경우
    - 규모가 큰 테이블
    - Insert, Update, Delete가 자주 발생하지 않는 컬럼
    - Join, Where, Order by 에 자주 사용되는 컬럼
    - 데이터 중복도가 낮은 컬럼
- Index의 자료구조
    - 해시 테이블
        - 데이터, 데이터의 위치를 key, value로 사용하여 인덱스를 구현
        - 시간복잡도가 O(1)로 빠름
        - = 연산에만 사용할 수 있음
            - Hash 연산으로 value가 결정되다 보니 부등호를 사용할 수 없음
    - B+Tree
        - 자식 노드가 2개 이상인 B-Tree를 개선
        - 리프 노드만 인덱스와함께 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만을 갖음
        - 리프 노드들은 Linked List로 연결되어 있음

- 클러스터 / 논 클러스터 인덱스
    - 클러스터 인덱스
        - 데이터와 인덱스가 클러스터링 되어 있다는 의미
        - 리프 노드는 실제 데이터, 루트 노드와 중간 노드는 리프 노드가 가지고 있는 페이지를 링크
        - 데이터는 pk(클러스터 인덱스)를 기준으로 정렬되어 있음
    - 논 클러스터 인덱스
        - 데이터와 인덱스가 클러스터링 되어 있지 않음
        - 별도의 공간을 만들어서 해당 인덱스를 기준으로 정렬하지만 실제 데이터는 정렬하지 않음
        - 리프 노드는 실제 데이터를 가리키는 포인터
        - 논 클러스터와 클러스터 인덱스를 같이 사용하는 경우 논 클러스터 인덱스를 검색하면 pk를 가지고 있고 해당 pk를 통해 클러스터 인덱스를 한 번 더 타서 데이터 검색